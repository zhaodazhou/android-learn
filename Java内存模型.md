# Java内存模型

参考：https://juejin.im/post/5bf2977751882505d840321d

## 组成分析

### 概念

内存模型理解为**在特定操作协议下，对特定的内存或高速缓存进行读写访问的过程抽象**。

Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，简称JMM）来**屏蔽掉各种硬件和操作系统的内存访问差异**，以实现**让Java程序在各种平台下都能达到一致的内存访问效果**，不必因为不同平台上的物理机的内存模型的差异，对各平台定制化开发程序。

Java内存模型提出目标在于，**定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节**。此处的变量(Variables)与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数值对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的。(如果局部变量是一个reference类型，它引用的对象在Java堆中可被各个线程共享，但是reference本身在Java栈的局部变量表中，它是线程私有的)。



### 组成

主内存 Java内存模型规定了所有变量都存储在主内存(Main Memory)中（此处的主内存与介绍物理硬件的主内存名字一样，两者可以互相类比，但此处仅是虚拟机内存的一部分）。

工作内存 每条线程都有自己的工作内存(Working Memory，又称本地内存，可与前面介绍的处理器高速缓存类比)，线程的工作内存中保存了该线程使用到的变量的主内存中的共享变量的副本拷贝。**工作内存是 JMM 的一个抽象概念，并不真实存在**。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。

示意图地址如下：

https://user-gold-cdn.xitu.io/2018/11/19/1672b9fc5988f121?imageView2/0/w/1280/h/960/format/webp/ignore-error/1



### 并发问题

**工作内存数据一致性**



**指令重排序优化**

为了程序性能，分**编译期重排序和运行期重排序**

要求：结果一致、不存在依赖关系



## 内存交互的基本操作

### 8种基本操作

![8种基本操作](https://user-gold-cdn.xitu.io/2018/11/19/1672b9fcfecdf9c5?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



lock (锁定) 作用于**主内存**的变量，它把一个变量标识为一条线程独占的状态。

unlock (解锁) 作用于**主内存**的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

read (读取) 作用于**主内存**的变量，它把一个变量的值从主内存**传输**到线程的工作内存中，以便随后的load动作使用。

load (载入) 作用于**工作内存**的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

use (使用) 作用于**工作内存**的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用到变量的值得字节码指令时就会执行这个操作。

assign (赋值) 作用于**工作内存**的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

store (存储) 作用于**工作内存**的变量，它把工作内存中一个变量的值传送到主内存中，以便随后write操作使用。

write (写入) 作用于**主内存**的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。



## 运行规则

### 3个特性

**原子性(Atomicity)** **即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行**。即使在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程所干扰。

**可见性(Visibility)** **是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值**。 正如上面“交互操作流程”中所说明的一样，JMM是通过在线程1变量工作内存修改后将新值同步回主内存，线程2在变量读取前从主内存刷新变量值，这种**依赖主内存作为传递媒介**的方式来实现可见性。

**有序性(Ordering)** 有序性规则表现在以下两种场景: 线程内和线程间

- 线程内 从某个线程的角度看方法的执行，指令会按照一种叫“串行”（as-if-serial）的方式执行，此种方式已经应用于顺序编程语言。
- 线程间 这个线程“观察”到其他线程并发地执行非同步的代码时，由于指令重排序优化，任何代码都有可能交叉执行。唯一起作用的约束是：对于同步方法，同步块(synchronized关键字修饰)以及volatile字段的操作仍维持相对有序。

Java内存模型的一系列运行规则看起来有点繁琐，但总结起来，是**围绕原子性、可见性、有序性特征建立**。归根究底，是为实现共享变量的在多个线程的工作内存的**数据一致性**，多线程并发，指令重排序优化的环境中程序能如预期运行。



## volatile

### 语义1 保证可见性

保证了不同线程对该变量操作的内存可见性。

这里保证可见性是不等同于volatile变量并发操作的安全性，保证可见性具体一点解释：

**线程写volatile变量的过程：**

- 1 改变线程工作内存中volatile变量副本的值
- 2 将改变后的副本的值从工作内存刷新到主内存

**线程读volatile变量的过程：**

- 1 从主内存中读取volatile变量的最新值到线程的工作内存中
- 2 从工作内存中读取volatile变量的副本



### 语义2 禁止进行指令重排序

具体一点解释，禁止重排序的规则如下：

- 当程序执行到 volatile变量的读操作或者写操作时，在其前面的操作的更改肯定全部已经进行，且结果已经对后面的操作可见；在其后面的操作肯定还没有进行；
- 在进行指令优化时，不能将在对 volatile 变量访问的语句放在其后面执行，也不能把 volatile 变量后面的语句放到其前面执行。



### volatile型变量实现原理

具体实现方式是在编译期生成字节码时，会在指令序列中增加内存屏障来保证，下面是基于保守策略的JMM内存屏障插入策略：

![volatile型变量内存屏障插入策略](https://user-gold-cdn.xitu.io/2018/11/19/1672b9fcff24e95a?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



### volatile型变量使用场景

总结起来，就是“一次写入，到处读取”，某一线程负责更新变量，其他线程只读取变量(不更新变量)，并根据变量的新值执行相应逻辑。例如状态标志位更新，观察者模型变量值发布。



## Runtime Data Area（运行时数据区）的结构

![img](https://imgconvert.csdnimg.cn/aHR0cHM6Ly9pbWcyMDE4LmNuYmxvZ3MuY29tL2Jsb2cvMTQ4OTY2OS8yMDE4MTAvMTQ4OTY2OS0yMDE4MTAwOTE4NTUyNzMxNi0xNzA4NzkwOTc0LnBuZw?x-oss-process=image/format,png)



根据 JVM 规范，JVM 内存共分为虚拟机栈、堆、方法区、程序计数器、本地方法栈五个部分。

